/* Autogenerated file. Do not edit manually. */

/* tslint:disable */

/* eslint-disable */
import type {
  TypedEventLog,
  TypedListener,
  TypedContractEvent,
  TypedLogDescription,
  TypedContractMethod,
  TypedDeferredTopicFilter
} from './common'
import type {
  Result,
  Listener,
  BytesLike,
  Interface,
  AddressLike,
  BaseContract,
  BigNumberish,
  EventFragment,
  ContractRunner,
  ContractMethod,
  FunctionFragment
} from 'ethers'

export declare namespace NftMarket {
  export type NftStruct = {
    tokenId: BigNumberish
    price: BigNumberish
    creator: AddressLike
    isListed: boolean
  }

  export type NftStructOutput = [
    tokenId: bigint,
    price: bigint,
    creator: string,
    isListed: boolean
  ] & { tokenId: bigint; price: bigint; creator: string; isListed: boolean }
}

export interface NftMarketInterface extends Interface {
  getFunction(
    nameOrSignature:
      | 'approve'
      | 'balanceOf'
      | 'getApproved'
      | 'isApprovedForAll'
      | 'name'
      | 'owner'
      | 'ownerOf'
      | 'renounceOwnership'
      | 'safeTransferFrom(address,address,uint256)'
      | 'safeTransferFrom(address,address,uint256,bytes)'
      | 'setApprovalForAll'
      | 'supportsInterface'
      | 'symbol'
      | 'tokenURI'
      | 'transferFrom'
      | 'transferOwnership'
      | 'setListingPrice'
      | 'mintToken'
      | 'getNft'
      | 'listedItemsCount'
      | 'buyNft'
      | 'getAllNftsOnSale'
      | 'getNftsByOwner'
      | 'placeNftOnSale'
  ): FunctionFragment

  getEvent(
    nameOrSignatureOrTopic:
      | 'Approval'
      | 'ApprovalForAll'
      | 'BatchMetadataUpdate'
      | 'MetadataUpdate'
      | 'OwnershipTransferred'
      | 'Transfer'
  ): EventFragment

  encodeFunctionData(
    functionFragment: 'approve',
    values: [AddressLike, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'balanceOf',
    values: [AddressLike]
  ): string
  encodeFunctionData(
    functionFragment: 'getApproved',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'isApprovedForAll',
    values: [AddressLike, AddressLike]
  ): string
  encodeFunctionData(functionFragment: 'name', values?: undefined): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'ownerOf',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'renounceOwnership',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256)',
    values: [AddressLike, AddressLike, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'safeTransferFrom(address,address,uint256,bytes)',
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'setApprovalForAll',
    values: [AddressLike, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [BytesLike]
  ): string
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'tokenURI',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'transferFrom',
    values: [AddressLike, AddressLike, BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [AddressLike]
  ): string
  encodeFunctionData(
    functionFragment: 'setListingPrice',
    values: [BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'mintToken',
    values: [string, BigNumberish]
  ): string
  encodeFunctionData(functionFragment: 'getNft', values: [BigNumberish]): string
  encodeFunctionData(
    functionFragment: 'listedItemsCount',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'buyNft', values: [BigNumberish]): string
  encodeFunctionData(
    functionFragment: 'getAllNftsOnSale',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'getNftsByOwner',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'placeNftOnSale',
    values: [BigNumberish, BigNumberish]
  ): string

  decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getApproved', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'isApprovedForAll',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'ownerOf', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'renounceOwnership',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom(address,address,uint256)',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'safeTransferFrom(address,address,uint256,bytes)',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setApprovalForAll',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'tokenURI', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'transferFrom',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'transferOwnership',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setListingPrice',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'mintToken', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'getNft', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'listedItemsCount',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'buyNft', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'getAllNftsOnSale',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getNftsByOwner',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'placeNftOnSale',
    data: BytesLike
  ): Result
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    approved: AddressLike,
    tokenId: BigNumberish
  ]
  export type OutputTuple = [owner: string, approved: string, tokenId: bigint]
  export interface OutputObject {
    owner: string
    approved: string
    tokenId: bigint
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export namespace ApprovalForAllEvent {
  export type InputTuple = [
    owner: AddressLike,
    operator: AddressLike,
    approved: boolean
  ]
  export type OutputTuple = [owner: string, operator: string, approved: boolean]
  export interface OutputObject {
    owner: string
    operator: string
    approved: boolean
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export namespace BatchMetadataUpdateEvent {
  export type InputTuple = [
    _fromTokenId: BigNumberish,
    _toTokenId: BigNumberish
  ]
  export type OutputTuple = [_fromTokenId: bigint, _toTokenId: bigint]
  export interface OutputObject {
    _fromTokenId: bigint
    _toTokenId: bigint
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export namespace MetadataUpdateEvent {
  export type InputTuple = [_tokenId: BigNumberish]
  export type OutputTuple = [_tokenId: bigint]
  export interface OutputObject {
    _tokenId: bigint
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike]
  export type OutputTuple = [previousOwner: string, newOwner: string]
  export interface OutputObject {
    previousOwner: string
    newOwner: string
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    tokenId: BigNumberish
  ]
  export type OutputTuple = [from: string, to: string, tokenId: bigint]
  export interface OutputObject {
    from: string
    to: string
    tokenId: bigint
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  export type Filter = TypedDeferredTopicFilter<Event>
  export type Log = TypedEventLog<Event>
  export type LogDescription = TypedLogDescription<Event>
}

export interface NftMarket extends BaseContract {
  connect(runner?: ContractRunner | null): NftMarket
  waitForDeployment(): Promise<this>

  interface: NftMarketInterface

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>

  /**
   * See {IERC721-approve}.
   */
  approve: TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >

  /**
   * See {IERC721-balanceOf}.
   */
  balanceOf: TypedContractMethod<[owner: AddressLike], [bigint], 'view'>

  /**
   * See {IERC721-getApproved}.
   */
  getApproved: TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>

  /**
   * See {IERC721-isApprovedForAll}.
   */
  isApprovedForAll: TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    'view'
  >

  /**
   * See {IERC721Metadata-name}.
   */
  name: TypedContractMethod<[], [string], 'view'>

  /**
   * Returns the address of the current owner.
   */
  owner: TypedContractMethod<[], [string], 'view'>

  /**
   * See {IERC721-ownerOf}.
   */
  ownerOf: TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
   */
  renounceOwnership: TypedContractMethod<[], [void], 'nonpayable'>

  /**
   * See {IERC721-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256)': TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >

  /**
   * See {IERC721-safeTransferFrom}.
   */
  'safeTransferFrom(address,address,uint256,bytes)': TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    'nonpayable'
  >

  /**
   * See {IERC721-setApprovalForAll}.
   */
  setApprovalForAll: TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    'nonpayable'
  >

  /**
   * See {IERC165-supportsInterface}
   */
  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    'view'
  >

  /**
   * See {IERC721Metadata-symbol}.
   */
  symbol: TypedContractMethod<[], [string], 'view'>

  /**
   * See {IERC721Metadata-tokenURI}.
   */
  tokenURI: TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>

  /**
   * See {IERC721-transferFrom}.
   */
  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    'nonpayable'
  >

  setListingPrice: TypedContractMethod<
    [newPrice: BigNumberish],
    [void],
    'nonpayable'
  >

  mintToken: TypedContractMethod<
    [tokenURI: string, price: BigNumberish],
    [void],
    'payable'
  >

  getNft: TypedContractMethod<
    [tokenId: BigNumberish],
    [NftMarket.NftStructOutput],
    'view'
  >

  listedItemsCount: TypedContractMethod<[], [bigint], 'view'>

  buyNft: TypedContractMethod<[tokenId: BigNumberish], [void], 'payable'>

  getAllNftsOnSale: TypedContractMethod<
    [],
    [NftMarket.NftStructOutput[]],
    'view'
  >

  getNftsByOwner: TypedContractMethod<[], [NftMarket.NftStructOutput[]], 'view'>

  placeNftOnSale: TypedContractMethod<
    [tokenId: BigNumberish, newPrice: BigNumberish],
    [void],
    'payable'
  >

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T

  getFunction(
    nameOrSignature: 'approve'
  ): TypedContractMethod<
    [to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >
  getFunction(
    nameOrSignature: 'balanceOf'
  ): TypedContractMethod<[owner: AddressLike], [bigint], 'view'>
  getFunction(
    nameOrSignature: 'getApproved'
  ): TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>
  getFunction(
    nameOrSignature: 'isApprovedForAll'
  ): TypedContractMethod<
    [owner: AddressLike, operator: AddressLike],
    [boolean],
    'view'
  >
  getFunction(
    nameOrSignature: 'name'
  ): TypedContractMethod<[], [string], 'view'>
  getFunction(
    nameOrSignature: 'owner'
  ): TypedContractMethod<[], [string], 'view'>
  getFunction(
    nameOrSignature: 'ownerOf'
  ): TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>
  getFunction(
    nameOrSignature: 'renounceOwnership'
  ): TypedContractMethod<[], [void], 'nonpayable'>
  getFunction(
    nameOrSignature: 'safeTransferFrom(address,address,uint256)'
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >
  getFunction(
    nameOrSignature: 'safeTransferFrom(address,address,uint256,bytes)'
  ): TypedContractMethod<
    [
      from: AddressLike,
      to: AddressLike,
      tokenId: BigNumberish,
      data: BytesLike
    ],
    [void],
    'nonpayable'
  >
  getFunction(
    nameOrSignature: 'setApprovalForAll'
  ): TypedContractMethod<
    [operator: AddressLike, approved: boolean],
    [void],
    'nonpayable'
  >
  getFunction(
    nameOrSignature: 'supportsInterface'
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], 'view'>
  getFunction(
    nameOrSignature: 'symbol'
  ): TypedContractMethod<[], [string], 'view'>
  getFunction(
    nameOrSignature: 'tokenURI'
  ): TypedContractMethod<[tokenId: BigNumberish], [string], 'view'>
  getFunction(
    nameOrSignature: 'transferFrom'
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, tokenId: BigNumberish],
    [void],
    'nonpayable'
  >
  getFunction(
    nameOrSignature: 'transferOwnership'
  ): TypedContractMethod<[newOwner: AddressLike], [void], 'nonpayable'>
  getFunction(
    nameOrSignature: 'setListingPrice'
  ): TypedContractMethod<[newPrice: BigNumberish], [void], 'nonpayable'>
  getFunction(
    nameOrSignature: 'mintToken'
  ): TypedContractMethod<
    [tokenURI: string, price: BigNumberish],
    [void],
    'payable'
  >
  getFunction(
    nameOrSignature: 'getNft'
  ): TypedContractMethod<
    [tokenId: BigNumberish],
    [NftMarket.NftStructOutput],
    'view'
  >
  getFunction(
    nameOrSignature: 'listedItemsCount'
  ): TypedContractMethod<[], [bigint], 'view'>
  getFunction(
    nameOrSignature: 'buyNft'
  ): TypedContractMethod<[tokenId: BigNumberish], [void], 'payable'>
  getFunction(
    nameOrSignature: 'getAllNftsOnSale'
  ): TypedContractMethod<[], [NftMarket.NftStructOutput[]], 'view'>
  getFunction(
    nameOrSignature: 'getNftsByOwner'
  ): TypedContractMethod<[], [NftMarket.NftStructOutput[]], 'view'>
  getFunction(
    nameOrSignature: 'placeNftOnSale'
  ): TypedContractMethod<
    [tokenId: BigNumberish, newPrice: BigNumberish],
    [void],
    'payable'
  >

  getEvent(
    key: 'Approval'
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >
  getEvent(
    key: 'ApprovalForAll'
  ): TypedContractEvent<
    ApprovalForAllEvent.InputTuple,
    ApprovalForAllEvent.OutputTuple,
    ApprovalForAllEvent.OutputObject
  >
  getEvent(
    key: 'BatchMetadataUpdate'
  ): TypedContractEvent<
    BatchMetadataUpdateEvent.InputTuple,
    BatchMetadataUpdateEvent.OutputTuple,
    BatchMetadataUpdateEvent.OutputObject
  >
  getEvent(
    key: 'MetadataUpdate'
  ): TypedContractEvent<
    MetadataUpdateEvent.InputTuple,
    MetadataUpdateEvent.OutputTuple,
    MetadataUpdateEvent.OutputObject
  >
  getEvent(
    key: 'OwnershipTransferred'
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >
  getEvent(
    key: 'Transfer'
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >

  filters: {
    'Approval(address,address,uint256)': TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >

    'ApprovalForAll(address,address,bool)': TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >
    ApprovalForAll: TypedContractEvent<
      ApprovalForAllEvent.InputTuple,
      ApprovalForAllEvent.OutputTuple,
      ApprovalForAllEvent.OutputObject
    >

    'BatchMetadataUpdate(uint256,uint256)': TypedContractEvent<
      BatchMetadataUpdateEvent.InputTuple,
      BatchMetadataUpdateEvent.OutputTuple,
      BatchMetadataUpdateEvent.OutputObject
    >
    BatchMetadataUpdate: TypedContractEvent<
      BatchMetadataUpdateEvent.InputTuple,
      BatchMetadataUpdateEvent.OutputTuple,
      BatchMetadataUpdateEvent.OutputObject
    >

    'MetadataUpdate(uint256)': TypedContractEvent<
      MetadataUpdateEvent.InputTuple,
      MetadataUpdateEvent.OutputTuple,
      MetadataUpdateEvent.OutputObject
    >
    MetadataUpdate: TypedContractEvent<
      MetadataUpdateEvent.InputTuple,
      MetadataUpdateEvent.OutputTuple,
      MetadataUpdateEvent.OutputObject
    >

    'OwnershipTransferred(address,address)': TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >

    'Transfer(address,address,uint256)': TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >
  }
}
